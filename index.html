<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Launch Pad R1</title>
    <style>
        :root {
            --bg-color: #0d0d0d;
            --font-color: #e0e0e0;
            --primary-color: #ff7043; /* Rabbit R1 Orange */
            --border-color: #2a2a2a;
            --item-bg: #1c1c1c;
            --icon-color: #7a7a7a; /* Slightly darker inactive color */
            --font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --selection-bg-color: rgba(255, 112, 67, 0.15); /* A tint of the primary color */
            --selection-border-color: var(--primary-color);
            --checkbox-border-color: #555;
            --checkbox-checked-bg: var(--primary-color);
        }
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--font-color);
            font-size: 14px; /* Base font size for smaller display */
            margin: 0;
        }
        .main-view {
            width: 100%;
            max-width: 480px;
            min-width: 240px;
            margin: 0 auto;
            /* Top padding is now handled by the header to fill the safe area with the background */
            padding: 0 8px 8px;
        }
        header {
            position: relative;
            /* Define a fixed height for the header area: safe area + content space */
            height: calc(var(--rabbit-safe-area-inset-top, 20px) + 38px);
            margin-bottom: 4px;
        }
        header img {
            position: absolute;
            height: 32px; /* A balanced height for the logo */
            object-fit: contain;
            /* Center the logo horizontally and vertically */
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        header #themeBtn {
            position: absolute;
            right: 0;
            /* Vertically center the button */
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: var(--primary-color);
            font-weight: bold;
            font-size: 0.9em;
            width: auto;
            height: auto;
            padding: 8px;
        }
        header #themeBtn:hover {
            background: var(--item-bg);
            filter: brightness(1.15);
        }
        /* In input mode, show the search and cancel buttons */
        .main-view.input-mode-active .search-section #searchBtn,
        .main-view.input-mode-active .search-section #cancelSearchBtn {
            display: flex;
            align-items: center; /* Vertically align with input */
        }
        /* When an input is active, hide the action bar to reduce clutter */
        .main-view.input-mode-active header,
        .main-view.input-mode-active .actions-bar {
            display: none;
        }
        .search-section {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }
        .search-input-wrapper {
            position: relative;
            flex-grow: 1;
            display: flex;
            align-items: center;
        }
        .search-input-wrapper input {
            width: 100%;
            /* Add padding to the right so text doesn't go under the 'X' button */
            padding-right: 30px;
        }
        #clearSearchBtn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: var(--icon-color);
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex; /* Use flex to center the SVG inside */
            align-items: center;
            justify-content: center;
        }
        #clearSearchBtn:hover {
            color: var(--font-color);
            filter: none; /* Override default button hover */
        }
        #clearSearchBtn svg {
            width: 20px;
            height: 20px;
        }
        /* Make action buttons consistent with view-control icons */
        #searchBtn, #quickLaunchBtn, #deleteAllBtn {
            background: transparent;
            border: none;
            padding: 0;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Hide the web search button by default on the main view */
        #searchBtn {
            display: none;
        }
        #quickLaunchBtn svg, #deleteAllBtn svg {
            width: 18px;
            height: 18px;
            fill: var(--icon-color);
        }
        #searchBtn svg {
            width: 16px; /* Smaller icon for search */
            height: 16px;
            fill: var(--icon-color);
        }
        input[type="text"] {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--item-bg);
            color: var(--font-color);
            font-size: 1em;
            min-width: 0; /* Fix for flexbox overflow */
        }
        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        button {
            padding: 8px 8px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            flex-shrink: 0; /* Prevent buttons from shrinking in flex containers */
        }
        button:hover {
            filter: brightness(1.15);
        }
        /* Override default hover for transparent icon buttons and give them a new one */
        #searchBtn:hover, #quickLaunchBtn:hover, #deleteAllBtn:hover {
            filter: none;
        }
        #deleteAllBtn:hover svg {
            fill: #e74c3c; /* A dangerous red */
        }
        #searchBtn:hover svg, #quickLaunchBtn:hover svg, .view-btn:hover svg {
            fill: var(--primary-color);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            filter: none;
        }
        /* Secondary button style for non-primary actions like 'Cancel' */
        button.secondary {
            background-color: var(--item-bg);
            border: 1px solid var(--border-color);
            color: var(--icon-color);
        }
        button.secondary:hover {
            background-color: #2c2c2c;
            color: var(--font-color);
            filter: none; /* Override the default button hover */
        }
        /* The cancel button is only shown in input mode */
        #cancelSearchBtn {
            display: none;
            padding: 4px 10px; /* More compact padding */
            font-size: 0.9em; /* Smaller font */
        }
        #linksList {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .link-item {
            background-color: var(--item-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: nowrap;
        }
        .add-suggestion-item {
            cursor: pointer;
        }
        .add-suggestion-item:hover {
            background-color: #252525;
        }
        .web-search-item {
            justify-content: center;
            cursor: pointer;
        }
        .web-search-item:hover {
            background-color: #2c2c2c;
            border-color: var(--primary-color);
        }
        .search-prompt {
            text-align: center;
            color: var(--icon-color);
            padding: 20px; /* Reduced padding to keep it visible with keyboard */
            font-size: 1em;
            line-height: 1.5;
            opacity: 0.8;
            user-select: none; /* Prevent text selection on this prompt */
        }
        .link-display {
            flex-grow: 1;
            overflow: hidden;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }
        .link-favicon {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
            background-color: #333;
            border-radius: 4px;
            object-fit: cover;
        }
        .link-info {
            flex-grow: 1;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .link-description {
            flex-grow: 1; /* Allow description to take available space */
            font-weight: bold;
            font-size: 0.9em;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .link-actions {
            display: flex;
            gap: 10px;
            flex-direction: column;
            flex-shrink: 0;
        }
        /* For the horizontal icons in the normal link view */
        .link-display > .link-actions {
            flex-direction: row;
            gap: 6px;
        }
        .link-actions span {
            cursor: pointer;
            font-size: 1.1em;
            color: var(--icon-color);
        }
        .link-actions span:hover { color: var(--primary-color); }
        .link-actions svg {
            width: 16px;
            height: 16px;
            display: block;
        }
        .favorite-btn.is-favorite {
            color: #FFD700; /* Gold, for high visibility across all themes */
        }
        .favorite-indicator {
            color: #E6C300; /* A slightly less bright gold */
            font-size: 0.85em; /* Make it a bit smaller than the header text */
            /* The star character can sometimes sit high, this helps align it */
            display: inline-block;
            transform: translateY(-1px);
        }
        .category-header {
            font-size: 1em;
            font-weight: bold;
            color: var(--primary-color);
            margin-top: 15px;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        #linksList > h3:first-of-type {
            margin-top: 0;
        }
        .link-info input, .link-info select {
            width: 100%;
            margin-top: 5px;
            padding: 6px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--item-bg);
            color: var(--font-color);
            font-size: 0.95em;
        }
        .link-info > *:first-child {
            margin-top: 0;
        }
        /* Styles for the two-step delete confirmation */
        .link-item.confirm-delete {
            background-color: #4d2a2a; /* A subtle red tint */
            border-color: #e74c3c;
        }
        .link-item.confirm-delete .link-actions .delete-btn {
            color: #e74c3c; /* Make the icon red */
        }
        /* Hide other actions during delete confirmation */
        .link-item.confirm-delete .link-actions .edit-btn,
        .link-item.confirm-delete .link-actions .favorite-btn {
            display: none;
        }

        /* --- Delete Prompt Styles --- */
        .delete-options {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Spacing between radio buttons */
        }
        .delete-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 1em;
        }
        .delete-options input[type="radio"] {
            /* Basic styling for radio buttons */
            accent-color: var(--primary-color);
        }
        .delete-link-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            user-select: none;
        }
        .delete-link-item:last-child {
            border-bottom: none;
        }
        .delete-link-item:hover {
            background-color: #2c2c2c;
        }
        .delete-link-item .delete-checkbox {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .delete-link-item .delete-checkbox svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        .delete-checkbox .icon-checkbox-unchecked {
            color: var(--checkbox-border-color);
        }
        .delete-checkbox .icon-checkbox-checked {
            color: var(--primary-color);
        }
        .delete-checkbox .icon-favorite {
            color: #FFD700; /* Gold */
        }
        .delete-link-item-description {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: bold;
        }

        /* --- Common Dialog List Styles --- */
        .favorites-list,
        .delete-links-list,
        .theme-color-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
        }

        /* --- Favorites Prompt Styles --- */
        .favorites-list {
            max-height: 65vh; /* Increased to show more items */
        }
        .delete-links-list {
            max-height: 45vh; /* Increased height for better visibility */
        }
        .theme-color-list {
            max-height: 40vh; /* Increased height to show more colors */
        }
        .favorite-list-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            user-select: none;
        }
        .favorite-list-item:last-child {
            border-bottom: none;
        }
        .favorite-list-item:hover {
            background-color: #2c2c2c;
        }
        .favorite-list-item-description {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: bold;
        }
        .custom-prompt-dialog .no-favorites-message {
            text-align: center; color: var(--icon-color); padding: 10px; font-weight: normal;
        }
        .remove-favorite-btn {
            flex-shrink: 0;
            cursor: pointer;
            color: var(--icon-color);
            padding: 4px; /* Easy tap target */
        }
        .remove-favorite-btn:hover {
            color: #e74c3c; /* Red for remove action */
        }
        .remove-favorite-btn svg {
            width: 16px;
            height: 16px;
            display: block;
        }

        .theme-color-item {
            padding: 8px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            user-select: none;
            font-weight: bold;
        }
        .theme-color-item:last-child {
            border-bottom: none;
        }
        .theme-color-item:hover {
            background-color: #2c2c2c;
        }
        .theme-color-list {
             /* Transitions for smooth collapse when keyboard is active */
            transition: opacity 0.2s ease-in-out, max-height 0.3s ease-in-out, margin 0.3s ease-in-out, padding 0.3s ease-in-out, border 0.3s ease-in-out;
        }

        /* --- Custom Scrollbar for Lists --- */
        .favorites-list::-webkit-scrollbar,
        .delete-links-list::-webkit-scrollbar,
        .theme-color-list::-webkit-scrollbar {
            width: 6px;
        }
        .favorites-list::-webkit-scrollbar-track,
        .delete-links-list::-webkit-scrollbar-track,
        .theme-color-list::-webkit-scrollbar-track {
            background: transparent;
        }
        .favorites-list::-webkit-scrollbar-thumb,
        .delete-links-list::-webkit-scrollbar-thumb,
        .theme-color-list::-webkit-scrollbar-thumb {
            background-color: var(--icon-color);
            border-radius: 3px;
            border: 2px solid var(--bg-color); /* Match list background for padding effect */
        }

        .scrollable-list-dialog:focus {
            outline: 1px solid var(--primary-color);
            outline-offset: 1px;
        }

        .actions-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px; /* Reduced to gain space */
        }
        .list-actions {
            display: flex;
            align-items: center;
            /* A larger gap to visually separate view controls from the quick launch button */
            gap: 20px; 
        }
        #toggleAllLink {
            color: var(--icon-color);
            text-decoration: none;
            font-size: 0.9em;
        }
        #toggleAllLink:hover {
            color: var(--primary-color);
        }
        .app-actions {
            display: flex;
            gap: 8px;
        }
        .view-controls {
            display: flex;
            gap: 10px;
        }
        .view-btn {
            cursor: pointer;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .view-btn svg {
            display: block;
            width: 18px;
            height: 18px;
            fill: var(--icon-color);
        }
        .view-btn.active svg {
            fill: var(--primary-color);
        }
        #quickLaunchBtn.active svg {
            /* A noticeable but not overly bright gold to make it stand out */
            fill: #E6C300; 
        }
        /* Group View Styles */
        .category-header.collapsible {
            cursor: pointer;
            position: relative;
            padding-right: 20px; /* Space for arrow */
        }
        .category-header.collapsible::after {
            content: '▶';
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%) rotate(0deg);
            font-size: 0.8em;
            transition: transform 0.2s ease;
        }
        .category-header.collapsible.expanded::after {
            transform: translateY(-50%) rotate(90deg);
        }
        .links-container {
            display: none;
            padding-top: 5px;
        }
        .links-container.expanded {
            display: block;
        }
        /* Custom Prompt Styles */
        .custom-prompt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            /* Align to top to avoid keyboard overlap on small screens */
            align-items: flex-start;
            z-index: 1000;
            padding: 10px 8px 8px; /* Further reduced top padding to bring dialog higher */
            transition: padding-top 0.2s ease-in-out; /* Smooth transition for focus */
        }
        .custom-prompt-overlay.input-focused {
            padding-top: 2px; /* Move dialog almost to the top edge to ensure buttons are visible */
        }
        .custom-prompt-dialog {
            background-color: var(--item-bg); 
            padding: 12px; /* Reduced padding */
            border-radius: 8px;
            border: 1px solid var(--border-color);
            width: 100%;
            max-width: 320px;
            display: flex;
            flex-direction: column; 
            gap: 8px; /* Reduced gap for a more compact look */
            transition: padding 0.2s ease-in-out, gap 0.2s ease-in-out; /* Smooth transition */
        }
        .custom-prompt-dialog .custom-prompt-title {
            margin: 0;
            font-weight: bold;
            text-align: center;
        }
        #genericPromptMessage {
            text-align: center;
            line-height: 1.5;
            font-weight: normal;
            /* Add a small top margin to prevent text from being clipped at the top of the dialog.
               Bottom margin is handled by the parent's flex-gap. */
            margin: 4px 0 0;
        }
        .custom-prompt-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        .custom-prompt-actions button {
            /* Make dialog buttons slightly smaller */
            padding: 6px 10px;
            font-size: 0.9em;
        }
        .custom-prompt-actions-right {
            display: flex;
            gap: 10px;
        }
        /* When keyboard is active, move dialog up to avoid overlap */
        .custom-prompt-overlay.input-focused {
            padding-top: 2px;
        }
        .custom-prompt-overlay.input-focused .custom-prompt-dialog {
            padding: 10px;
            gap: 5px;
        }
        .custom-prompt-overlay.input-focused .theme-color-list {
            /* Hide the list when typing to save space */
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            margin-bottom: 0;
            border-width: 0;
        }
        .custom-prompt-error {
            color: #e74c3c; /* A noticeable red */
            font-size: 0.9em;
            text-align: center;
            margin: 0;
            min-height: 1.2em; /* Reserve space to prevent layout shift */
        }
        .custom-prompt-error:empty {
            /* Hide the element completely when there is no error message to show */
            min-height: 0;
        }
    </style>
</head>
<body>
    <div id="mainView" class="main-view">
        <header>
            <img src="launchpad-logo.png" alt="Launch Pad R1 Logo">
            <button id="themeBtn" title="Change Theme">Theme!</button>
        </header>
        <div class="search-section">
            <div class="search-input-wrapper">
                <input type="text" id="searchInput" placeholder="Search or Add..." autocomplete="off">
                <button id="clearSearchBtn" title="Clear search" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"></path></svg>
                </button>
            </div>
            <button id="searchBtn" title="Search with DuckDuckGo">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M18.031 16.617l4.283 4.282-1.415 1.415-4.282-4.283A8.96 8.96 0 0 1 11 20c-4.968 0-9-4.032-9-9s4.032-9 9-9 9 4.032 9 9a8.96 8.96 0 0 1-1.969 5.617zm-2.006-.742A6.977 6.977 0 0 0 18 11c0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7a6.977 6.977 0 0 0 4.875-1.975l.15-.15z"/></svg>
            </button>
            <button id="cancelSearchBtn" class="secondary">Cancel</button>
        </div>
        <div class="actions-bar">
            <div class="list-actions">
                <div class="view-controls">
                    <span id="toggleViewBtn" class="view-btn"></span>
                </div>
                <a href="#" id="toggleAllLink" style="display: none;"></a>
                <button id="quickLaunchBtn" title="Launch Favorite">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 18.26l-7.053 3.948 1.575-7.928L.587 8.792l8.027-.952L12 .5l3.386 7.34 8.027.952-5.935 5.488 1.575 7.928z"></path></svg>
                </button>
            </div>
            <div class="app-actions">
                <button id="deleteAllBtn" title="Delete All Links">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                    </svg>
                </button>
            </div>
        </div>

        <ul id="linksList"></ul>
    </div>
    
    <div id="themeDialogOverlay" class="custom-prompt-overlay" style="display: none;">
        <div class="custom-prompt-dialog">
            <p class="custom-prompt-title">Change Theme</p>
            <p id="themeDialogError" class="custom-prompt-error"></p>
            <ul id="themeColorList" class="theme-color-list scrollable-list-dialog" tabindex="-1"></ul>
            <input type="text" id="themeDialogInput" placeholder="Or type a name/hex here">
            <div class="custom-prompt-actions">
                <button id="themeDialogReset" class="secondary">Rabbit Me!</button>
                <div class="custom-prompt-actions-right">
                    <button id="themeDialogCancel" class="secondary">Cancel</button>
                    <button id="themeDialogOk">OK</button>
                </div>
            </div>
        </div>
    </div>

    <div id="deletePromptOverlay" class="custom-prompt-overlay" style="display: none;">
        <div class="custom-prompt-dialog">
            <div class="delete-options">
                <label><input type="radio" name="delete-mode" value="all"> Delete All Links</label>
                <label><input type="radio" name="delete-mode" value="keep-favs"> Delete All Except Favorite</label>
                <label><input type="radio" name="delete-mode" value="selected" checked> Select Links to Delete:</label>
            </div>
            <ul id="deleteLinksList" class="delete-links-list scrollable-list-dialog" tabindex="-1">
                <!-- Links will be populated here by JS -->
            </ul>
            <div class="custom-prompt-actions">
                <button id="deletePromptCancel" class="secondary">Cancel</button>
                <button id="deletePromptOk">Delete</button>
            </div>
        </div>
    </div>

    <div id="favoritesPromptOverlay" class="custom-prompt-overlay" style="display: none;">
        <div class="custom-prompt-dialog">
            <p class="custom-prompt-title">Favorites</p>
            <ul id="favoritesList" class="favorites-list scrollable-list-dialog" tabindex="-1">
                <!-- Favorite links will be populated here by JS -->
            </ul>
            <div class="custom-prompt-actions">
                <button id="favoritesPromptClose" style="width: 100%;">Close</button>
            </div>
        </div>
    </div>

    <div id="genericPromptOverlay" class="custom-prompt-overlay" style="display: none;">
        <div class="custom-prompt-dialog">
            <p id="genericPromptMessage"></p>
            <div id="genericPromptActions" class="custom-prompt-actions">
                <!-- Buttons are dynamically added here by JS -->
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const mainView = document.getElementById('mainView');
        const searchInput = document.getElementById('searchInput');
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        const searchBtn = document.getElementById('searchBtn');
        const linksList = document.getElementById('linksList');
        const toggleViewBtn = document.getElementById('toggleViewBtn');
        const quickLaunchBtn = document.getElementById('quickLaunchBtn');
        const toggleAllLink = document.getElementById('toggleAllLink');
        const cancelSearchBtn = document.getElementById('cancelSearchBtn');
        const themeBtn = document.getElementById('themeBtn');
        const deleteAllBtn = document.getElementById('deleteAllBtn');
        const themeDialogOverlay = document.getElementById('themeDialogOverlay');
        const themeDialogError = document.getElementById('themeDialogError');
        const themeColorList = document.getElementById('themeColorList');
        const themeDialogInput = document.getElementById('themeDialogInput');
        const themeDialogOk = document.getElementById('themeDialogOk');
        const themeDialogCancel = document.getElementById('themeDialogCancel');
        const themeDialogReset = document.getElementById('themeDialogReset');
        const deletePromptOverlay = document.getElementById('deletePromptOverlay');
        const deleteLinksList = document.getElementById('deleteLinksList');
        const deletePromptCancel = document.getElementById('deletePromptCancel');
        const deletePromptOk = document.getElementById('deletePromptOk');
        const favoritesPromptOverlay = document.getElementById('favoritesPromptOverlay');
        const favoritesList = document.getElementById('favoritesList');
        const favoritesPromptClose = document.getElementById('favoritesPromptClose');
        const genericPromptOverlay = document.getElementById('genericPromptOverlay');
        const genericPromptMessage = document.getElementById('genericPromptMessage');
        const genericPromptActions = document.getElementById('genericPromptActions');

        let suggestionRequestCount = 0;
        const GENERIC_FAVICON_SRC = 'data:image/svg+xml,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'%23888\'%3e%3cpath d=\'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z\'/%3e%3c/svg%3e';

        /**
         * Launches a URL on the Rabbit r1 device, with a voice confirmation.
         * Includes a fallback for browser-based testing.
         * @param {string} url The URL to launch.
         * @param {string} name A descriptive name for the URL being launched.
         */
        async function launchUrlOnRabbit(url, name) {
            try {
                if (window.rabbit && window.rabbit.core) {
                    await window.rabbit.core.say({ text: `Launching ${name}` });
                    await window.rabbit.core.launchUrl({ url: url });
                } else {
                    console.log(`[Browser Mode] Launching: ${name} at ${url}`);
                    window.location.href = url;
                }
            } catch (error) {
                console.error("Error launching URL on Rabbit:", error);
                await showAlert("Failed to launch URL.");
            }
        }

        /**
         * Triggers a short haptic vibration if on the Rabbit device.
         */
        function triggerHaptic() {
            try {
                if (window.rabbit && window.rabbit.core && window.rabbit.core.vibrate) {
                    window.rabbit.core.vibrate({ pattern: [50] }); // A short 50ms vibration
                }
            } catch (e) { console.error("Haptic feedback failed:", e); }
        }

        /**
         * Scrolls the main window to the top, ensuring the header is visible.
         */
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        /**
         * Returns a function, that, as long as it continues to be invoked, will not
         * be triggered. The function will be called after it stops being called for
         * N milliseconds.
         */
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        // --- Generic Alert/Confirm Dialogs ---
        function showGenericPrompt({ message, buttons }) {
            return new Promise(resolve => {
                genericPromptMessage.textContent = message;
                genericPromptActions.innerHTML = ''; // Clear old buttons

                // Ensure buttons are added in a specific order for layout (e.g., Cancel on left)
                const sortedButtons = buttons.sort((a, b) => (a.order || 0) - (b.order || 0));

                sortedButtons.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.textContent = btnConfig.text;
                    if (btnConfig.class) {
                        button.className = btnConfig.class;
                    }
                    button.onclick = () => {
                        genericPromptOverlay.style.display = 'none';
                        resolve(btnConfig.value);
                    };
                    genericPromptActions.appendChild(button);
                });

                genericPromptActions.style.justifyContent = buttons.length === 1 ? 'center' : 'space-between';
                genericPromptOverlay.style.display = 'flex';
            });
        }

        async function showAlert(message) {
            return showGenericPrompt({
                message,
                buttons: [ { text: 'OK', value: true, class: '' } ]
            });
        }

        async function showConfirm(message) {
            return showGenericPrompt({
                message,
                buttons: [
                    { text: 'Cancel', value: false, class: 'secondary', order: 1 },
                    { text: 'OK', value: true, class: '', order: 2 }
                ]
            });
        }
        // Categories are sorted alphabetically, with 'Other' at the end for better usability.
        const categories = ['Education', 'Entertainment', 'Finance', 'Music', 'News', 'Shopping', 'Social', 'Sports', 'Tools', 'Travel', 'Other'];

        let links = JSON.parse(localStorage.getItem('launchPadR1Links')) || [
            { description: 'Youtube', url: 'https://m.youtube.com', category: 'Entertainment' },
            { description: 'Copilot', url: 'https://copilot.microsoft.com/', category: 'Tools' },
            { description: 'Radio.net', url: 'https://www.radio.net/', category: 'Music' }
        ];

        // --- Migration & State Initialization ---
        // Migration to add unique IDs to links for robust favoriting/editing.
        let needsSave = false;
        links.forEach((link, index) => {
            if (!link.id) {
                link.id = `link-${Date.now()}-${index}`;
                needsSave = true;
            }
        });

        // Migration from old index-based favorite to new ID-based favorite.
        const oldFavoriteIndex = parseInt(localStorage.getItem('launchPadR1FavoriteLinkIndex') || '-1', 10);
        const oldFavoriteLinkId = localStorage.getItem('launchPadR1FavoriteLinkId');
        let favoriteLinkIds = new Set(JSON.parse(localStorage.getItem('launchPadR1FavoriteLinkIds')) || []);

        // --- Migration from single favorite to multiple favorites ---
        if (oldFavoriteLinkId && favoriteLinkIds.size === 0) {
            favoriteLinkIds.add(oldFavoriteLinkId);
            localStorage.setItem('launchPadR1FavoriteLinkIds', JSON.stringify(Array.from(favoriteLinkIds)));
        } else if (oldFavoriteIndex !== -1 && links[oldFavoriteIndex] && favoriteLinkIds.size === 0) {
            favoriteLinkIds.add(links[oldFavoriteIndex].id);
            localStorage.setItem('launchPadR1FavoriteLinkIds', JSON.stringify(Array.from(favoriteLinkIds)));
        }
        // Clean up old keys
        if (localStorage.getItem('launchPadR1FavoriteLinkIndex') || localStorage.getItem('launchPadR1FavoriteLinkId')) {
            localStorage.removeItem('launchPadR1FavoriteLinkIndex');
            localStorage.removeItem('launchPadR1FavoriteLinkId');
        }

        let currentView = localStorage.getItem('launchPadR1View') || 'list';
        let collapsedCategories = JSON.parse(localStorage.getItem('launchPadR1CollapsedCategories')) || [];
        let currentThemeName = localStorage.getItem('launchPadR1Theme') || 'rabbit';

        // Simple migration for old data without categories
        links.forEach(link => {
            if (!link.category) {
                link.category = 'Other';
            }
        });

        function updateToggleAllLinkState() {
            if (currentView !== 'group') {
                toggleAllLink.style.display = 'none';
                return;
            }
            
            // Get all unique categories from the complete, unfiltered `links` array.
            const allCategoriesInApp = [...new Set(links.map(link => link.category || 'Other'))];
            // Check if there is at least one category that is NOT in the collapsed list.
            const hasExpandedCategory = allCategoriesInApp.some(cat => !collapsedCategories.includes(cat));

            if (hasExpandedCategory) {
                toggleAllLink.textContent = 'Collapse All';
                toggleAllLink.style.display = 'block';
            } else {
                toggleAllLink.style.display = 'none';
            }
        }

        function renderLinks(linksToRender = links) {
            // Update the view toggle button to show the icon for the *other* view.
            if (currentView === 'list') {
                // Currently in list view, so show the icon to switch to group view.
                toggleViewBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 3h8v8H3V3zM13 3h8v8h-8V3zM3 13h8v8H3v-8zM13 13h8v8h-8v-8z"/></svg>`;
                toggleViewBtn.title = 'Group View';
            } else { // group view
                // Currently in group view, so show the icon to switch to list view.
                toggleViewBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 4H21V6H3V4ZM3 11H21V13H3V11ZM3 18H21V20H3V18Z" /></svg>`;
                toggleViewBtn.title = 'List View';
            }

            quickLaunchBtn.classList.toggle('active', favoriteLinkIds.size > 0);

            // Clear the list and prepare a document fragment for efficient rendering.
            linksList.innerHTML = '';
            const fragment = document.createDocumentFragment();

            if (linksToRender.length === 0) {
                const query = searchInput.value.trim();
                // For empty states, we can directly set innerHTML as it's simple and a single operation.
                // No need for the fragment optimization here.
                if (query) {
                    // Always offer to add the query. The handleAddFromQuery function is smart
                    // enough to handle both single and multi-word queries appropriately.
                    linksList.innerHTML = `
                        <li class="link-item add-suggestion-item">
                            <div class="link-favicon" style="display: flex; align-items: center; justify-content: center; font-size: 22px; color: var(--primary-color);">+</div>
                            <div class="link-description">Add "${query}"</div>
                        </li>
                    `;
                    linksList.querySelector('.add-suggestion-item').addEventListener('click', () => handleAddFromQuery(query));
                } else {
                    linksList.innerHTML = '<p style="text-align:center; color: #6c757d;">No links saved. Click "+ Add" to start.</p>';
                }
                return;
            }

            const groupedLinks = linksToRender.reduce((acc, link) => {
                const category = link.category || 'Other';
                if (!acc[category]) {
                    acc[category] = [];
                }
                acc[category].push(link);
                return acc;
            }, {});

            // Sort links within each category alphabetically by description
            for (const category in groupedLinks) {
                groupedLinks[category].sort((a, b) => a.description.localeCompare(b.description));
            }

            const sortedCategories = Object.keys(groupedLinks).sort((a, b) => {
                if (a === 'Other') return 1;
                if (b === 'Other') return -1;
                return a.localeCompare(b);
            });

            const favoriteCategories = new Set(links.filter(l => favoriteLinkIds.has(l.id)).map(l => l.category));

            updateToggleAllLinkState();

            if (currentView === 'list') {
                sortedCategories.forEach(category => {
                    const categoryHeader = document.createElement('h3'); 
                    categoryHeader.className = 'category-header';
                    if (favoriteCategories.has(category)) {
                        categoryHeader.innerHTML = `${category} <span class="favorite-indicator">★</span>`;
                    } else {
                        categoryHeader.textContent = category;
                    }
                    fragment.appendChild(categoryHeader);

                    groupedLinks[category].forEach(link => fragment.appendChild(renderLinkItem(link, linksToRender)));
                });
            } else { // Group View
                sortedCategories.forEach(category => {
                    const categoryHeader = document.createElement('h3');
                    categoryHeader.className = 'category-header collapsible';
                    if (favoriteCategories.has(category)) {
                        categoryHeader.innerHTML = `${category} <span class="favorite-indicator" aria-hidden="true">★</span>`;
                    } else {
                        categoryHeader.textContent = category;
                    }
                    fragment.appendChild(categoryHeader);
                    
                    const linksContainer = document.createElement('div');
                    linksContainer.className = 'links-container';
                    groupedLinks[category].forEach(link => linksContainer.appendChild(renderLinkItem(link, linksToRender)));
                    fragment.appendChild(linksContainer);

                    const isSearching = searchInput.value.trim() !== '';
                    // Check if this category should be expanded or collapsed from memory
                    const isCollapsed = collapsedCategories.includes(category);

                    // If the user is searching, always expand the resulting categories.
                    // Otherwise, respect the user's collapsed/expanded preference.
                    if (isSearching || !isCollapsed) {
                        categoryHeader.classList.add('expanded');
                        linksContainer.classList.add('expanded');
                    }
                });
            }

            // Append the fully constructed fragment to the DOM in one go.
            linksList.appendChild(fragment);
        }

        /**
         * Extracts the hostname from a URL for favicon services. Returns the original string if invalid.
         * @param {string} url The full URL.
         * @returns {string} The hostname (e.g., "www.google.com").
         */
        function getHostname(url) {
            try {
                return new URL(url).hostname;
            } catch (e) { return url; } // Fallback for invalid URLs
        }

        function renderLinkItem(link, sourceArray = links) {
            if (!link.id) return; // Should not happen with migration

            const li = document.createElement('li');
            li.className = 'link-item';
            li.dataset.id = link.id;

            const isFavorite = favoriteLinkIds.has(link.id);

            li.innerHTML = `
                <img src="https://www.google.com/s2/favicons?sz=64&domain_url=${getHostname(link.url)}" class="link-favicon" alt="Favicon" onerror="this.onerror=null; this.src='${GENERIC_FAVICON_SRC}'; this.style.padding='3px';">
                <div class="link-display">
                    <div class="link-description">${link.description}</div>
                    <div class="link-actions">
                        <span class="favorite-btn" title="Set as favorite">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 18.26l-7.053 3.948 1.575-7.928L.587 8.792l8.027-.952L12 .5l3.386 7.34 8.027.952-5.935 5.488 1.575 7.928z"></path></svg>
                        </span>
                        <span class="edit-btn" title="Edit"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M15.7279 9.57627L14.3137 8.16206L5.82842 16.6473V18H7.18263L15.7279 9.57627ZM17.1421 8.16206L18.5563 6.74785L17.1421 5.33363L15.7279 6.74785L17.1421 8.16206ZM7.24264 20H3V15.7574L14.435 4.32233C14.8256 3.93181 15.4587 3.93181 15.8492 4.32233L19.6777 8.15076C20.0682 8.54128 20.0682 9.17445 19.6777 9.56497L8.24264 21H7.24264V20Z"></path></svg></span>
                        <span class="delete-btn" title="Delete"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M17 6H22V8H20V21C20 21.5523 19.5523 22 19 22H5C4.44772 22 4 21.5523 4 21V8H2V6H7V3C7 2.44772 7.44772 2 8 2H16C16.5523 2 17 2.44772 17 3V6ZM18 8H6V20H18V8ZM9 11H11V17H9V11ZM13 11H15V17H13V11ZM9 4V6H15V4H9Z"></path></svg></span>
                    </div>
                </div>
            `;
            // Style the favorite button if it's the current favorite
            if (isFavorite) {
                li.querySelector('.favorite-btn')?.classList.add('is-favorite');
            }
            return li;
        }

        function setView(view) {
            currentView = view;
            localStorage.setItem('launchPadR1View', view);
            renderLinks();
        }
        
        function saveLinks() {
            localStorage.setItem('launchPadR1Links', JSON.stringify(links));
            localStorage.setItem('launchPadR1FavoriteLinkIds', JSON.stringify(Array.from(favoriteLinkIds)));
        }

        function resetDeleteConfirmationState(item) {
            if (!item) return;
            item.classList.remove('confirm-delete');
            const deleteBtn = item.querySelector('.delete-btn');
            if (deleteBtn && item.dataset.originalDeleteSvg) {
                deleteBtn.querySelector('svg').innerHTML = item.dataset.originalDeleteSvg;
                deleteBtn.setAttribute('title', 'Delete');
                deleteBtn.style.color = ''; // Reset color
            }
        }


        function handleCategoryToggle(headerElement) {
            const linksContainer = headerElement.nextElementSibling;
            if (!linksContainer || !linksContainer.classList.contains('links-container')) return;

            linksContainer.classList.toggle('expanded');
            headerElement.classList.toggle('expanded');

            // Update and save the collapsed state
            const categoryName = headerElement.textContent.replace(' ★', '');
            const isNowExpanded = linksContainer.classList.contains('expanded');
            if (isNowExpanded) {
                collapsedCategories = collapsedCategories.filter(c => c !== categoryName);
            } else {
                if (!collapsedCategories.includes(categoryName)) {
                    collapsedCategories.push(categoryName);
                }
            }
            localStorage.setItem('launchPadR1CollapsedCategories', JSON.stringify(collapsedCategories));
            updateToggleAllLinkState();
        }

        function handleDeleteLink(index) {
            const deletedLink = links[index];
            if (!deletedLink) return;

            links.splice(index, 1);
            // If the deleted link was a favorite, remove it from the set.
            if (favoriteLinkIds.has(deletedLink.id)) {
                favoriteLinkIds.delete(deletedLink.id);
            }
            saveLinks();
            // Re-render based on current search to reflect the deletion
            searchHandler(searchInput.value);
        }

        function handleLaunchLink(li, index) {
            // If the item is in edit mode (has an edit input), do not launch.
            if (li.querySelector('.edit-description')) {
                return;
            }
            // If item is awaiting delete confirmation, cancel it instead of launching.
            if (li.classList.contains('confirm-delete')) {
                resetDeleteConfirmationState(li);
                return;
            }
            const link = links[index];
            triggerHaptic();
            launchUrlOnRabbit(link.url, link.description);
        }

        linksList.addEventListener('click', async (e) => {
            const target = e.target;

            // Cancel any pending delete if user clicks outside of the confirming item.
            const activeConfirmation = document.querySelector('.link-item.confirm-delete');
            if (activeConfirmation && !activeConfirmation.contains(target.closest('.link-item'))) {
                resetDeleteConfirmationState(activeConfirmation);
            }

            const li = target.closest('.link-item');

            // Handle category collapse/expand in 'group' view
            const categoryHeader = target.closest('.category-header.collapsible');
            if (currentView === 'group' && categoryHeader) {
                handleCategoryToggle(categoryHeader);
                return;
            }

            if (!li) return;
            const id = li.dataset.id;
            const index = links.findIndex(l => l.id === id);
            if (index === -1) return; // Link not found, maybe from a stale render

            if (target.closest('.delete-btn')) {
                if (li.classList.contains('confirm-delete')) {
                    handleDeleteLink(index); // This will now just delete, no confirm
                } else {
                    // Enter confirmation state
                    li.classList.add('confirm-delete');
                    const deleteBtn = target.closest('.delete-btn');
                    const svgEl = deleteBtn.querySelector('svg');
                    li.dataset.originalDeleteSvg = svgEl.innerHTML;
                    svgEl.innerHTML = '<path d="M9.9997 15.1709L19.1921 5.97852L20.6063 7.39273L9.9997 18.0003L3.63574 11.6364L5.04996 10.2222L9.9997 15.1709Z"></path>'; // Checkmark
                    deleteBtn.setAttribute('title', 'Confirm Delete');
                }
            } else if (target.closest('.edit-btn')) {
                editLink(li, index);
            } else if (target.closest('.favorite-btn')) {
                if (favoriteLinkIds.has(id)) {
                    favoriteLinkIds.delete(id);
                } else {
                    favoriteLinkIds.add(id);
                }
                triggerHaptic();
                saveLinks();
                searchHandler(searchInput.value); // Re-render to show the new favorite state
            } else if (target.closest('.link-display') || target.closest('.link-favicon')) {
                handleLaunchLink(li, index);
            }
        });

        /**
         * Creates the HTML for the add/edit form.
         * @param {object|null} link - The link object to edit, or null for a new link.
         * @returns {string} The innerHTML for the form.
         */
        function createFormHTML(linkData = {}, isForEditing = false) {
            const description = linkData.description || '';
            const url = linkData.url || 'https://';
            const selectedCategory = linkData.category || 'Other';

            const categoryOptions = categories.map(cat => 
                `<option value="${cat}" ${selectedCategory === cat ? 'selected' : ''}>${cat}</option>`
            ).join('');

            const inputClassPrefix = isForEditing ? 'edit' : 'new';
            const saveButtonClass = isForEditing ? 'save-btn' : 'save-new-btn';

            return `
                <div class="link-info">
                    <input type="text" class="${inputClassPrefix}-description" value="${description}" placeholder="Description">
                    <input type="text" class="${inputClassPrefix}-url" value="${url}" placeholder="URL (e.g., https://...)">
                    <select class="${inputClassPrefix}-category">${categoryOptions}</select>
                    <div class="form-actions">
                        <button class="cancel-btn secondary">Cancel</button>
                        <button class="${saveButtonClass}">${isForEditing ? 'Save' : 'Add'}</button>
                    </div>
                </div>
            `;
        }

        function editLink(li, index) {
            const link = links[index];
            // Temporarily remove the favicon during edit to maximize space
            li.innerHTML = createFormHTML(link, true);

            li.querySelector('.save-btn').addEventListener('click', async () => {
                const newDescription = li.querySelector('.edit-description').value.trim();
                const newUrl = li.querySelector('.edit-url').value.trim();
                const newCategory = li.querySelector('.edit-category').value;
                if (newDescription && newUrl) {
                    links[index] = { // Preserve the ID
                        ...links[index],
                        description: newDescription,
                        url: newUrl,
                        category: newCategory
                    }; 
                    saveLinks();
                    searchHandler(searchInput.value); // Re-apply filter to show the change
                } else {
                    await showAlert('Description and URL cannot be empty.');
                }
            });
            li.querySelector('.cancel-btn').addEventListener('click', () => {
                searchHandler(searchInput.value); // Re-render the list to cancel, respecting filter
            });
        }

        async function showAddForm(prefillData = {}) {
            // Prevent adding another new item if one is already being added
            const existingNewInput = document.querySelector('.new-description');
            if (existingNewInput) {
                const existingForm = existingNewInput.closest('.link-item');
                // If there's prefill data, update the existing blank form
                if (prefillData.description) {
                    existingForm.querySelector('.new-description').value = prefillData.description;
                }
                if (prefillData.url) {
                    existingForm.querySelector('.new-url').value = prefillData.url;
                }
                existingForm.querySelector('.new-description').focus();
                return;
            }

            const li = document.createElement('li');
            li.className = 'link-item';
            li.innerHTML = createFormHTML(prefillData, false);
            linksList.appendChild(li);

            // Scroll to the new item and focus the description input
            li.scrollIntoView({ behavior: 'smooth' });
            // Focus the most relevant input based on what's pre-filled
            if (prefillData.description && prefillData.url && prefillData.url !== 'https://') {
                // If both are pre-filled (quick-add), focus category for quick change.
                li.querySelector('.new-category').focus();
            } else if (prefillData.description) {
                // If only description is pre-filled (complex query), focus URL for entry.
                li.querySelector('.new-url').focus();
            } else {
                // If nothing is pre-filled (manual add), focus description.
                li.querySelector('.new-description').focus();
            }

            const saveHandler = async () => {
                const description = li.querySelector('.new-description').value.trim();
                const url = li.querySelector('.new-url').value.trim();
                const category = li.querySelector('.new-category').value;
                await addNewLink({ description, url, category });
            };

            li.querySelector('.save-new-btn').addEventListener('click', saveHandler);
            li.querySelector('.cancel-btn').addEventListener('click', () => {
                li.remove();
                searchHandler(''); // Re-render full list, clearing the search
            });
        }

        async function handleAddFromQuery(description, url) {
            if (!description) return;

            // Clear suggestions from the list before showing the form.
            linksList.innerHTML = '';

            let prefillData = {};
            const hasSpaces = description.includes(' ');

            if (hasSpaces) {
                // For complex queries, just pre-fill the description.
                prefillData = { description: description.replace(/\b\w/g, l => l.toUpperCase()), url: url || 'https://' };
            } else {
                // For simple queries, pre-fill both description and a guessed URL.
                const finalUrl = url || (() => {
                    const hasProtocol = description.startsWith('http://') || description.startsWith('https://');
                    const looksLikeDomain = description.includes('.');
                    return hasProtocol ? description : (looksLikeDomain ? `https://${description}` : `https://www.${description}.com`);
                })();
                const finalDescription = description.split('.')[0].replace(/^(https?:\/\/)?(www\.)?/, '').replace(/\b\w/g, l => l.toUpperCase());
                prefillData = { description: finalDescription, url: finalUrl, category: 'Other' };
            }
            await showAddForm(prefillData);
        }

        async function addNewLink(linkData) {
            if (!linkData || !linkData.description || !linkData.url || linkData.url === 'https://') {
                await showAlert('Please provide a description and a full URL.');
                return false;
            }
            links.push({ ...linkData, id: `link-${Date.now()}` });
            saveLinks();

            // --- Enhancement: Expand the category of the newly added link ---
            // This provides immediate visual confirmation to the user in Group View.
            const newCategory = linkData.category || 'Other';
            collapsedCategories = collapsedCategories.filter(c => c !== newCategory);
            localStorage.setItem('launchPadR1CollapsedCategories', JSON.stringify(collapsedCategories));

            searchInput.value = '';
            renderLinks(); // Render the full, updated list

            try {
                if (window.rabbit && window.rabbit.core) {
                    window.rabbit.core.say({ text: `Added ${linkData.description}` });
                }
            } catch (e) { console.error("Say feedback failed:", e); }
            return true;
        }

        async function performExternalSearch(queryOverride) {
            const query = queryOverride || searchInput.value.trim();
            if (query) {
                // Provide immediate feedback that the launch is happening. This prevents the
                // UI from flashing back to the main list before the external URL is launched.
                linksList.innerHTML = `<div class="search-prompt">Launching web search for "${query}"...</div>`;

                const searchUrl = `https://duckduckgo.com/?q=${encodeURIComponent(query)}`;
                await launchUrlOnRabbit(searchUrl, `search for ${query}`);
            } else {
                // If called with no query (e.g. empty search box + enter), just show the main list.
                searchHandler('');
            }
        }

        function renderCombinedResults(query, apiSuggestions, localResults) {
            const fragment = document.createDocumentFragment();
            let hasContent = false;

            // Render local search results first, as they are most relevant to the user.
            if (localResults.length > 0) {
                const header = document.createElement('h3');
                header.className = 'category-header';
                header.textContent = 'In Your Links';
                fragment.appendChild(header);
                hasContent = true;
                localResults.forEach(link => fragment.appendChild(renderLinkItem(link)));
            }

            // Filter out web suggestions that already exist in the user's links to prevent duplicates.
            const existingUrls = new Set(links.map(link => link.url.replace(/\/$/, ''))); // Normalize by removing trailing slash
            const filteredApiSuggestions = apiSuggestions.filter(sugg => {
                const normalizedSuggUrl = sugg.link.replace(/\/$/, '');
                return !existingUrls.has(normalizedSuggUrl);
            });

            // Render API suggestions second.
            if (filteredApiSuggestions.length > 0) {
                const header = document.createElement('h3');
                header.className = 'category-header';
                header.textContent = 'Web Suggestions';
                if (hasContent) { // If we already rendered local results, add space
                    header.style.marginTop = '15px';
                }
                fragment.appendChild(header);
                hasContent = true;

                filteredApiSuggestions.slice(0, 4).forEach(sugg => {
                    const suggLi = document.createElement('li');
                    suggLi.className = 'link-item add-suggestion-item';
                    suggLi.innerHTML = `
                        <img src="https://www.google.com/s2/favicons?sz=64&domain_url=${getHostname(sugg.link)}" class="link-favicon" alt="Favicon" onerror="this.onerror=null; this.src='${GENERIC_FAVICON_SRC}'; this.style.padding='3px';">
                        <div class="link-description">Add: ${sugg.title}</div>
                    `;
                    suggLi.addEventListener('click', () => handleAddFromQuery(sugg.title, sugg.link));
                    fragment.appendChild(suggLi);
                });
            }

            // Always add a final option to perform an external web search. This makes the
            // action predictable and teaches the user what the search button does.
            const webSearchLi = document.createElement('li');
            webSearchLi.className = 'link-item web-search-item';
            webSearchLi.innerHTML = `
                <div class="link-favicon" style="display: flex; align-items: center; justify-content: center;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--primary-color)" width="20" height="20"><path d="M18.031 16.617l4.283 4.282-1.415 1.415-4.282-4.283A8.96 8.96 0 0 1 11 20c-4.968 0-9-4.032-9-9s4.032-9 9-9 9 4.032 9 9a8.96 8.96 0 0 1-1.969 5.617zm-2.006-.742A6.977 6.977 0 0 0 18 11c0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7a6.977 6.977 0 0 0 4.875-1.975l.15-.15z"/></svg>
                </div>
                <div class="link-description">Search for "${query}" on the web</div>
            `;
            webSearchLi.addEventListener('click', () => performExternalSearch(query));
            fragment.appendChild(webSearchLi);
            
            // Clear the list and append the new results in one operation.
            linksList.innerHTML = '';
            linksList.appendChild(fragment);
        }

        function handleOSMessage(e, requestQuery) {
            // First, check if the results are still relevant. If the user has changed the
            // search text since this request was sent, discard the incoming results.
            const currentQueryInBox = searchInput.value.trim();
            if (requestQuery.toLowerCase() !== currentQueryInBox.toLowerCase()) {
                console.log(`Stale results for "${requestQuery}" received, but input is now "${currentQueryInBox}". Discarding.`);
                return;
            }

            console.log("Received plugin message for query:", requestQuery, e);
            try {
                let data = null;
                if (e.data) {
                    data = typeof e.data == "string" ? JSON.parse(e.data) : e.data;
                }
                
                // Use the 'requestQuery' which is guaranteed to be the one that generated these results.
                const queryForFilter = requestQuery.trim().toLowerCase();
                const localResults = links.filter(link => 
                    link.description.toLowerCase().includes(queryForFilter) ||
                    link.url.toLowerCase().includes(queryForFilter)
                );

                if (data && data.organic_results) {
                    console.log("Google search results received:", data.organic_results.length, "results");
                    // Pass the original-case query to the render function for display purposes.
                    renderCombinedResults(requestQuery, data.organic_results, localResults);
                } else {
                    console.log("Received data but no organic_results. Falling back to local search.");
                    renderCombinedResults(requestQuery, [], localResults);
                }
            } catch (err) {
                console.error("Error parsing plugin message:", err);
            }
        }

        function searchHandler(query) {
            query = query.trim();
            if (!query) {
                renderLinks(links); // Render all links if query is empty
                return;
            }

            // Check if we are on the Rabbit device
            if (typeof PluginMessageHandler !== "undefined") {
                // By setting the handler here, we create a closure. This specific instance
                // of the handler "knows" which 'query' it is for. This prevents race
                // conditions where a response for an old query arrives after a new
                // query has been typed.
                window.onPluginMessage = function(e) {
                    handleOSMessage(e, query);
                };
                const messageToOS = {
                    message: JSON.stringify({
                        query_params: {
                            engine: "google", // Use Google for general web search
                            q: query,
                            hl: "en"
                        },
                        useLocation: false
                    }),
                    useSerpAPI: true
                };
                PluginMessageHandler.postMessage(JSON.stringify(messageToOS));
            } else {
                // --- Browser Mode: Use Mock Data for Testing ---
                console.log("[Browser Mode] Simulating search for:", query);
                const mockApiResults = [
                    { title: `Mock Result for '${query}'`, link: `https://www.example.com/search?q=${query}` },
                    { title: "The Verge - Tech News", link: "https://www.theverge.com" },
                    { title: "Hacker News", link: "https://news.ycombinator.com" }
                ];
                const localResults = links.filter(link => 
                    link.description.toLowerCase().includes(query.toLowerCase()) ||
                    link.url.toLowerCase().includes(query.toLowerCase())
                );
                // Simulate the async nature and the check for stale results
                setTimeout(() => {
                    const currentQueryInBox = searchInput.value.trim();
                    if (query.toLowerCase() === currentQueryInBox.toLowerCase()) {
                        renderCombinedResults(query, mockApiResults, localResults);
                    } else {
                        console.log(`[Browser Mode] Stale results for "${query}" received, but input is now "${currentQueryInBox}". Discarding.`);
                    }
                }, 200); // 200ms mock delay
            }
        }

        searchBtn.addEventListener('click', () => performExternalSearch());
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performExternalSearch();
            }
        });

        const debouncedSearch = debounce(searchHandler, 400);
        searchInput.addEventListener('input', () => {
            const query = searchInput.value;
            clearSearchBtn.style.display = query.length > 0 ? 'flex' : 'none';
            // In input mode, hide the 'Cancel' button when the user starts typing.
            if (mainView.classList.contains('input-mode-active')) {
                cancelSearchBtn.style.display = query.length > 0 ? 'none' : 'flex';
            }
            debouncedSearch(query);
        });

        cancelSearchBtn.addEventListener('click', () => {
            searchInput.value = '';
            clearSearchBtn.style.display = 'none';
            cancelSearchBtn.style.display = 'none';
            // Re-render the full list immediately
            searchHandler('');
            // Blurring the input will trigger the focusout event, which hides the input-mode UI
            searchInput.blur();
            scrollToTop();
        });

        // --- Global Input Focus Handling ---
        // When any text input or select is focused, hide non-essential UI to maximize space.
        mainView.addEventListener('focusin', (e) => {
            if (e.target.matches('input[type="text"], select')) {
                mainView.classList.add('input-mode-active');

                // Special handling for the main search input
                if (e.target.id === 'searchInput') {
            const query = e.target.value.trim();
            // When focusing, hide the 'Cancel' button if there's already text.
            cancelSearchBtn.style.display = query.length > 0 ? 'none' : 'flex';
            // Also ensure the clear button is shown if there's text.
            clearSearchBtn.style.display = query.length > 0 ? 'flex' : 'none';

                    // If the search input is empty when focused, clear the list and show a prompt.
            if (query === '') {
                        linksList.innerHTML = `<div class="search-prompt">Search your links or add from the web.</div>`;
                    }
                    // Scroll it into view to avoid the keyboard.
                    setTimeout(() => {
                        const searchSection = document.querySelector('.search-section');
                        if (searchSection) {
                            searchSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 100);
                }
            }
        });

        mainView.addEventListener('focusout', (e) => {
            if (e.target.matches('input[type="text"], select')) {
                // Use a small delay. If focus moves to another input, the 'input-mode-active'
                // class will still be present. If it moves to a button or outside, we check.
                setTimeout(() => {
                    const activeEl = document.activeElement;
                    // If the new active element is not an input/select inside our main view, then we can hide the bars.
                    if (!mainView.contains(activeEl) || !activeEl.matches('input[type="text"], select')) {
                        mainView.classList.remove('input-mode-active');
                    }

                    // If the search input was blurred and is now empty, restore the full list.
                    if (e.target.id === 'searchInput' && e.target.value.trim() === '') {
                        searchHandler('');
                    }
                }, 150);
            }
        });

        clearSearchBtn.addEventListener('click', () => {
            searchInput.value = '';
            clearSearchBtn.style.display = 'none';
            // With the input cleared, show the 'Cancel' button again.
            cancelSearchBtn.style.display = 'flex';
            searchHandler(''); // This will re-render all links
            searchInput.focus();
            triggerHaptic(); // Give feedback on clear
        });
        
        toggleViewBtn.addEventListener('click', () => {
            setView(currentView === 'list' ? 'group' : 'list');
        });

        toggleAllLink.addEventListener('click', (e) => {
            e.preventDefault();
            
            // Get all unique categories from the complete, unfiltered `links` array.
            const allCategoriesInApp = [...new Set(links.map(link => link.category || 'Other'))];

            // The link only appears when there's something to collapse, so its only action is to collapse all.
            collapsedCategories = [...allCategoriesInApp];
            localStorage.setItem('launchPadR1CollapsedCategories', JSON.stringify(collapsedCategories));
            searchHandler(searchInput.value); // Re-render respecting the current search query
        });

        // --- Quick Launch Event Listener ---
        function openFavoritesDialog() {
            function renderFavoritesList() {
                favoritesList.innerHTML = '';
                const favoriteLinks = links.filter(l => favoriteLinkIds.has(l.id))
                                           .sort((a, b) => a.description.localeCompare(b.description));

                if (favoriteLinks.length === 0) {
                    favoritesList.innerHTML = `<p class="no-favorites-message">No favorites set yet.<br>Click the star on any link to add it here.</p>`;
                    // If the last favorite was removed, update the main quick launch button state
                    quickLaunchBtn.classList.remove('active');
                } else {
                    const fragment = document.createDocumentFragment();
                    favoriteLinks.forEach(link => {
                        const li = document.createElement('li');
                        li.className = 'favorite-list-item';
                        li.dataset.id = link.id;
                        li.dataset.url = link.url;
                        li.dataset.name = link.description;
                        li.innerHTML = `
                            <img src="https://www.google.com/s2/favicons?sz=64&domain_url=${getHostname(link.url)}" class="link-favicon" alt="Favicon" onerror="this.onerror=null; this.src='${GENERIC_FAVICON_SRC}'; this.style.padding='3px';">
                            <span class="favorite-list-item-description">${link.description}</span>
                            <span class="remove-favorite-btn" title="Remove from favorites">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"></path></svg>
                            </span>
                        `;
                        fragment.appendChild(li);
                    });
                    favoritesList.appendChild(fragment);
                }
            }

            renderFavoritesList();
            favoritesPromptOverlay.style.display = 'flex';
            favoritesList.focus();

            const closeDialog = () => {
                favoritesPromptOverlay.style.display = 'none';
                favoritesList.onclick = null;
                favoritesPromptClose.onclick = null;
                scrollToTop();
            };

            favoritesList.onclick = async (e) => {
                const removeBtn = e.target.closest('.remove-favorite-btn');
                if (removeBtn) {
                    const li = removeBtn.closest('.favorite-list-item');
                    const linkName = li.dataset.name;
                    const confirmed = await showConfirm(`Remove "${linkName}" from favorites?`);

                    if (confirmed) {
                        const idToRemove = li.dataset.id;
                        favoriteLinkIds.delete(idToRemove);
                        saveLinks();
                        triggerHaptic();
                        renderFavoritesList(); // Re-render the popup list
                        renderLinks(); // Re-render the main list in the background
                    }
                } else {
                    const li = e.target.closest('.favorite-list-item');
                    if (li) {
                        closeDialog();
                        launchUrlOnRabbit(li.dataset.url, li.dataset.name);
                    }
                }
            };
            favoritesPromptClose.onclick = closeDialog;
        }

        quickLaunchBtn.addEventListener('click', async () => {
            if (favoriteLinkIds.size === 0) {
                if (window.rabbit && window.rabbit.core) {
                    await window.rabbit.core.say({ text: "No favorite link set." });
                } else { 
                    await showAlert("No favorite link set. Click the star on a link to set it as a favorite."); 
                }
                return;
            }
            triggerHaptic();
            openFavoritesDialog(); // No need to await this as it manages its own lifecycle
        });

        // --- Theming ---

        const CSS_COLOR_NAMES = ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'RebeccaPurple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'].sort();

        function setupThemePicker() {
            const list = themeColorList;
            list.innerHTML = '';
            const fragment = document.createDocumentFragment();
            CSS_COLOR_NAMES.forEach(name => {
                const li = document.createElement('li');
                li.className = 'theme-color-item';
                li.textContent = name;
                li.dataset.colorName = name;
                fragment.appendChild(li);
            });
            list.appendChild(fragment);

            list.addEventListener('click', async (e) => {
                const li = e.target.closest('.theme-color-item');
                if (li) {
                    triggerHaptic();
                    const colorName = li.dataset.colorName;
                    // Apply the theme immediately when a color is picked from the list.
                    // The dialog remains open for the user to try other colors or close it.
                    const applyResult = await applyTheme(`custom:${colorName}`);
                    if (!applyResult.success) {
                        themeDialogError.textContent = applyResult.error;
                    } else {
                        // Clear any previous error message on success.
                        themeDialogError.textContent = '';
                    }
                }
            });
        }

        const defaultTheme = { name: 'Rabbit', colors: { '--primary-color': '#ff7043', '--bg-color': '#0d0d0d', '--item-bg': '#1c1c1c', '--border-color': '#2a2a2a', '--icon-color': '#7a7a7a' } };

        function colorNameToRgb(name) {
            const el = document.createElement('div');
            // Set a known, unique color that is unlikely to be the result of a valid name.
            const magicColor = 'rgb(1, 2, 3)';
            el.style.color = magicColor; 
            document.body.appendChild(el);

            // Now, try to set the user's color.
            el.style.color = name;
            const computedColor = window.getComputedStyle(el).color;
            
            document.body.removeChild(el);

            // If the computed color is still our magic color, the name was invalid.
            if (computedColor === magicColor || computedColor === 'rgba(0, 0, 0, 0)' || computedColor === 'transparent') return null;

            const rgb = computedColor.match(/\d+/g).map(Number);
            return rgb;
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h, s, l];
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) { r = g = b = l; } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1; if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1 / 3);
            }
            return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
        }

        function generatePaletteFromRgb(rgb) {
            const [r, g, b] = rgb;
            if (r < 30 && g < 30 && b < 30) return null;
            const [h, s, l] = rgbToHsl(r, g, b);
            return {
                '--primary-color': `rgb(${r}, ${g}, ${b})`,
                '--bg-color': hslToRgb(h, s * 0.5, 0.07),
                '--item-bg': hslToRgb(h, s * 0.6, 0.12),
                '--border-color': hslToRgb(h, s * 0.6, 0.18),
                '--icon-color': hslToRgb(h, s * 0.3, 0.5)
            };
        }

        async function applyTheme(themeIdentifier) {
            let themeColors;
            let friendlyName;
            let error = null;

            if (themeIdentifier.startsWith('custom:')) {
                const colorName = themeIdentifier.split(':')[1];
                const primaryRgb = colorNameToRgb(colorName);
                if (!primaryRgb) {
                    error = `'${colorName}' is not a valid color.`;
                } else {
                    themeColors = generatePaletteFromRgb(primaryRgb);
                    if (!themeColors) {
                        error = "This color is too dark. Please choose a lighter color.";
                    } else {
                        friendlyName = colorName;
                    }
                }
            } else {
                themeColors = defaultTheme.colors;
                friendlyName = defaultTheme.name;
            }

            if (error) {
                return { success: false, error: error };
            }

            if (!themeColors) return { success: true }; // Should not happen if no error

            for (const [key, value] of Object.entries(themeColors)) {
                document.documentElement.style.setProperty(key, value);
            }
            currentThemeName = themeIdentifier;
            localStorage.setItem('launchPadR1Theme', themeIdentifier);

            // Provide feedback
            try {
                if (window.rabbit && window.rabbit.core) {
                    await window.rabbit.core.say({ text: `Theme set to ${friendlyName}` });
                }
            } catch (e) { console.error("Say feedback failed:", e); }
            
            return { success: true };
        }

        // Add listeners to adjust layout when keyboard is likely visible
        themeDialogInput.addEventListener('focus', () => {
            themeDialogOverlay.classList.add('input-focused');
        });
        themeDialogInput.addEventListener('blur', () => {
            // Use a small delay. If focus moves to another element inside the dialog (like a button),
            // we don't want to remove the class. We only remove it if focus has truly left the dialog.
            setTimeout(() => {
                if (!themeDialogOverlay.contains(document.activeElement)) {
                    themeDialogOverlay.classList.remove('input-focused');
                }
            }, 150);
        });

        function openThemeEditor() {
            themeDialogInput.value = '';
            themeDialogError.textContent = '';
            themeDialogOverlay.style.display = 'flex';
            themeColorList.scrollTop = 0;
            
            // When the dialog is shown, ensure the focused class is not present initially.
            themeDialogOverlay.classList.remove('input-focused');
        }

        function setupThemeDialogListeners() {
            const closeDialog = () => {
                themeDialogOverlay.style.display = 'none';
                scrollToTop();
            };

            themeDialogOk.addEventListener('click', async () => {
                const colorInput = themeDialogInput.value.trim();
                if (colorInput) {
                    triggerHaptic();
                    const applyResult = await applyTheme(`custom:${colorInput}`);
                    if (!applyResult.success) {
                        themeDialogError.textContent = applyResult.error;
                    } else {
                        // On successful application, close the dialog.
                        closeDialog();
                    }
                } else {
                    // If the input is empty, "OK" simply closes the dialog,
                    // keeping any theme that was live-previewed from the list.
                    closeDialog();
                }
            });

            themeDialogInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    themeDialogOk.click(); // Simulate a click on the OK button
                }
            });

            themeDialogCancel.addEventListener('click', closeDialog);

            themeDialogOverlay.addEventListener('click', (e) => {
                if (e.target.id === 'themeDialogOverlay') {
                    closeDialog();
                }
            });

            themeDialogReset.addEventListener('click', async () => {
                triggerHaptic();
                await applyTheme('rabbit');
                closeDialog(); // Reset and close
            });
        }


        // --- Delete Logic ---
        function openDeleteDialog() {
            const deleteModeRadios = document.querySelectorAll('input[name="delete-mode"]');

            const CHECKBOX_UNCHECKED_SVG = `<svg class="icon-checkbox-unchecked" viewBox="0 0 24 24" fill="currentColor"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/></svg>`;
            const CHECKBOX_CHECKED_SVG = `<svg class="icon-checkbox-checked" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>`;
            const FAVORITE_SVG = `<svg class="icon-favorite" viewBox="0 0 24 24" fill="currentColor"><path d="M12 18.26l-7.053 3.948 1.575-7.928L.587 8.792l8.027-.952L12 .5l3.386 7.34 8.027.952-5.935 5.488 1.575 7.928z"></path></svg>`; 

            let selectedIds = new Set();

            function renderDeleteList() {
                deleteLinksList.innerHTML = '';
                const fragment = document.createDocumentFragment();
                // Create a sorted copy of the links array for consistent ordering.
                const sortedLinks = [...links].sort((a, b) => a.description.localeCompare(b.description));
                sortedLinks.forEach(link => {
                    const li = document.createElement('li');
                    li.className = 'delete-link-item';
                    li.dataset.id = link.id;

                    const isFav = favoriteLinkIds.has(link.id);
                    const isSelected = selectedIds.has(link.id);

                    let icon = CHECKBOX_UNCHECKED_SVG;
                    if (isSelected) {
                        icon = CHECKBOX_CHECKED_SVG;
                    } else if (isFav) {
                        icon = FAVORITE_SVG;
                    }

                    li.innerHTML = `
                        <span class="delete-checkbox">${icon}</span>
                        <span class="delete-link-item-description">${link.description}</span>
                    `;
                    fragment.appendChild(li);
                });
                deleteLinksList.appendChild(fragment);
            }

            function updateSelectionFromMode() {
                const mode = document.querySelector('input[name="delete-mode"]:checked').value;
                selectedIds.clear();
                if (mode === 'all') {
                    links.forEach(link => selectedIds.add(link.id));
                } else if (mode === 'keep-favs') {
                    links.forEach(link => {
                        if (!favoriteLinkIds.has(link.id)) {
                            selectedIds.add(link.id);
                        }
                    });
                }
                // 'selected' mode just clears it, for manual selection.
                renderDeleteList();
            }

            function updateButtonState() {
                const mode = document.querySelector('input[name="delete-mode"]:checked').value;
                if (mode === 'selected') {
                    deletePromptOk.disabled = selectedIds.size === 0;
                } else {
                    // For 'all' and 'keep-favs', the button should always be enabled.
                    // The logic later handles cases where 'keep-favs' results in 0 deletions.
                    deletePromptOk.disabled = false;
                }
            }

            return new Promise((resolve) => {
                // Reset to default state
                document.querySelector('input[name="delete-mode"][value="selected"]').checked = true;
                selectedIds.clear();
                renderDeleteList();
                deletePromptOverlay.style.display = 'flex';
                deleteLinksList.scrollTop = 0; // Ensure list starts at the top
                deleteLinksList.focus();

                updateButtonState(); // Set initial button state

                const handleItemClick = (e) => {
                    const li = e.target.closest('.delete-link-item');
                    if (!li) return;

                    // Switch to manual selection mode
                    document.querySelector('input[name="delete-mode"][value="selected"]').checked = true;

                    const id = li.dataset.id;
                    if (selectedIds.has(id)) {
                        selectedIds.delete(id);
                    } else {
                        selectedIds.add(id);
                    }
                    renderDeleteList(); // Re-render to show the change
                    updateButtonState();
                };

                const handleModeChange = () => {
                    updateSelectionFromMode();
                    updateButtonState();
                };

                // Attach event listeners
                deleteLinksList.addEventListener('click', handleItemClick);
                deleteModeRadios.forEach(radio => radio.addEventListener('change', handleModeChange));

                const closeDialog = (value) => {
                    // Clean up listeners
                    deleteLinksList.removeEventListener('click', handleItemClick);
                    deleteModeRadios.forEach(radio => radio.removeEventListener('change', handleModeChange));
                    deletePromptOk.onclick = null;
                    deletePromptCancel.onclick = null;
                    
                    deletePromptOverlay.style.display = 'none';
                    resolve(value);
                };

                deletePromptOk.onclick = () => {
                    const mode = document.querySelector('input[name="delete-mode"]:checked').value;
                    closeDialog({ mode, ids: Array.from(selectedIds) });
                };

                deletePromptCancel.onclick = () => {
                    closeDialog(null);
                };
            });
        }

        deleteAllBtn.addEventListener('click', async () => {
            const result = await openDeleteDialog();
            if (!result || (result.mode === 'selected' && result.ids.length === 0)) {
                return; // User cancelled or selected nothing
            }

            let confirmMessage = '';
            let linksToDelete = new Set();
            const totalLinks = links.length;

            if (result.mode === 'all') {
                confirmMessage = `Are you sure you want to delete all ${totalLinks} link(s)?`;
                links.forEach(link => linksToDelete.add(link.id));
            } else if (result.mode === 'keep-favs') {
                const toDeleteCount = links.filter(l => !favoriteLinkIds.has(l.id)).length;
                if (toDeleteCount === 0) {
                    await showAlert("No links to delete (all links are favorites).");
                    return;
                }
                confirmMessage = `Are you sure you want to delete ${toDeleteCount} non-favorite link(s)?`;
                links.forEach(link => {
                    if (!favoriteLinkIds.has(link.id)) {
                        linksToDelete.add(link.id);
                    }
                });
            } else if (result.mode === 'selected') {
                confirmMessage = `Are you sure you want to delete ${result.ids.length} selected link(s)?`;
                result.ids.forEach(id => linksToDelete.add(id));
            }

            const confirmed = await showConfirm(confirmMessage);
            if (confirmed) {
                links = links.filter(link => !linksToDelete.has(link.id));
                // The set of favorites is the intersection of old favorites and the ones we didn't delete.
                const remainingLinkIds = new Set(links.map(l => l.id));
                favoriteLinkIds = new Set([...favoriteLinkIds].filter(id => remainingLinkIds.has(id)));

                saveLinks();
                renderLinks();
                scrollToTop();
                try {
                    if (window.rabbit && window.rabbit.core) {
                        window.rabbit.core.say({ text: "Links deleted." });
                    }
                } catch (e) { console.error("Say feedback failed:", e); }
            }
        });

        themeBtn.addEventListener('click', openThemeEditor);

        // --- Initial Load ---
        setupThemePicker();
        setupThemeDialogListeners();
        // Apply the initial theme
        applyTheme(currentThemeName);
        
        renderLinks();

    });
    </script>
</body>
</html>